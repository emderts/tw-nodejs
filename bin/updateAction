#!/usr/bin/env node

const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: true
}); 
const monster = require('../monster');

const day = new Date().getDay();
const hour = new Date().getHours();
const min = new Date().getMinutes();
doWork();

async function doWork() {
try {
  const client = await pool.connect();
  // 30분마다 (기본 피로도, 필드보스, 던전)
  await client.query('update characters set actionPoint = actionPoint + 1 where actionPoint < 100');
  
  const resultg = await client.query('select * from global');
  for (val of resultg.rows) {
    var glb = JSON.parse(val.globals);
    if (glb.fieldBossSummoned && !glb.fieldBossSpawned) {
      await client.query('insert into news(content, date) values ($1, $2)', 
        ['고대 흑마법사가 나타났습니다!', new Date()]);
      await client.query('insert into raids(rindex, open, phase, monsters) values (3, \'O\', 1, $1)', 
        [JSON.stringify({1 : monster.rKines1, 2 : monster.rInfernal, 3 : monster.rKines2})]);
      glb.fieldBossSpawned = true;
    }
    if (!glb.fieldBossSummoned && glb.actionUsed >= 200) {
      await client.query('insert into news(content, date) values ($1, $2)', 
        ['고대 흑마법사의 기운이 느껴집니다..', new Date()]);
      glb.fieldBossSummoned = true;
    }
  }
  await client.query('update global set globals = $1', [JSON.stringify(glb)]);
  
    const resultx = await client.query('select * from characters');
    for (val of resultx.rows) {
      var charData = JSON.parse(val.char_data);
      charData.dungeonInfos.runMevious = false;
      charData.dungeonInfos.runEmberCrypt = false;
      charData.dungeonInfos.runFieldBoss = false;
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
    } 
  
  // 3시간마다 (승급)
  if (hour % 3 == 0 && min < 25) {  
    const result = await client.query('select * from characters');
    for (val of result.rows) {
      var charData = JSON.parse(val.char_data);
      charData.dungeonInfos.runRankup = false;
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
    } 
  }
  
  // 6시간마다 (탄생일)
  if (hour % 6 == 0 && min < 25) {  
    const result = await client.query('select * from characters');
    for (val of result.rows) {
      var charData = JSON.parse(val.char_data);
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
      await client.query('update characters set actionPoint = actionPoint + 2 where uid = $1', [val.uid]);
      if (charData.birth == day) {
        await client.query('update characters set actionPoint = actionPoint + 3 where uid = $1', [val.uid]);
      }
    } 
  }
  
  // 주말 보너스
  if ((day == 0 || day == 6) && hour % 6 == 0 && min < 25) {
    await client.query('update characters set actionPoint = actionPoint + 3');
    await client.query('update characters set actionPoint = 100 where actionPoint > 100');
  }  
  
  // 6시 처리 (보너스 피로도, 던전 보상, 주간 리셋, 퀘스트)
  if (hour == 6 && min < 25) {
    await client.query('update characters set actionPoint = actionPoint + 3');
    await client.query('update characters set actionPoint = 100 where actionPoint > 100');
  
    const result = await client.query('select * from characters');
    var minBattle = 999999;
    var minBattleUid;
    var minRate = 2;
    var minRateUid;
    for (val of result.rows) {
      var charData = JSON.parse(val.char_data);
      if (day == 1) {
        charData.dayStoneBought = 0;
        delete charData.actionBought;
      }
      if (val.uid != '02' && val.uid != '12') {
        if (charData.battleCnt < minBattle) {
          minBattle = charData.battleCnt;
          minBattleUid = val.uid;
        }
        if (charData.battleCnt && charData.winCnt / charData.battleCnt < minRate) {
          minRate = charData.winCnt / charData.battleCnt;
          minRateUid = val.uid;
        }
      }
      charData.maxExp = 5 * charData.reqExp;
      charData.matchCount = 10;
      charData.resultMaxGauge = 0;
      charData.addExpCount = 3;
      charData.dungeonInfos.rewardMevious2 = false;
      charData.dungeonInfos.rewardMevious4 = false;
      charData.dungeonInfos.rewardMevious6 = false;
      charData.dungeonInfos.rewardMevious8 = false;
      charData.dungeonInfos.rewardMevious10 = false;
      charData.dungeonInfos.rewardMevious12 = false;
      charData.dungeonInfos.rewardMevious14 = false;
      charData.dungeonInfos.rewardMevious16 = false;
      charData.dungeonInfos.rewardMevious18 = false;
      charData.dungeonInfos.rewardMevious20 = false;
      charData.dungeonInfos.enterMevious = 3;
      charData.dungeonInfos.taurusReward = 3;
      charData.dungeonInfos.rewardEmberCrypt = false;
      charData.dungeonInfos.enterEmberCrypt = 3;
      charData.dungeonInfos.resetMevious = false;
      charData.dungeonInfos.resetEmberCrypt = false;
      charData.resetGauge = false;
      charData.quest = {};
      var quests = [{code : 1, progress : 0, target : 5},
                    {code : 2, progress : 0, target : 5},
                    {code : 3, progress : 0, target : 10},
                    {code : 4, progress : 0, target : 5},
                    {code : 5, progress : 0, target : 3},
                    {code : 6, progress : 0, target : 8},
                    {code : 7, progress : 0, target : 2},
                    {code : 8, progress : 0, target : 1},
                    {code : 9, progress : 0, target : 1},
                    {code : 10, progress : 0, target : 10},
                    {code : 11, progress : 0, target : 1},
                    {code : 12, progress : 0, target : 50}];
      var rand = Math.floor(Math.random() * 12);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1);
      var rand = Math.floor(Math.random() * 11);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1);
      var rand = Math.floor(Math.random() * 10);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1); 
      charData.resetQuest = true;
      
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
    } 
    const result2 = await client.query('select * from characters');
    for (val of result2.rows) {
      if (val.uid == minBattleUid) {
        var charData = JSON.parse(val.char_data);
        charData.expBoost = charData.expBoost ? charData.expBoost + 3 : 3;
        charData.maxExp += charData.reqExp;
        await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
        await client.query('insert into news(content, date) values ($1, $2)', 
          ['전투 횟수가 가장 적은 ' + charData.name + '에게 경험치 보정이 주어졌습니다!', new Date()]);
      }
      if (minBattleUid != minRateUid && val.uid == minRateUid) {
        var charData = JSON.parse(val.char_data);
        charData.expBoost = charData.expBoost ? charData.expBoost + 3 : 3;
        charData.maxExp += charData.reqExp;
        await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
        await client.query('insert into news(content, date) values ($1, $2)', 
          ['승률이 가장 낮은 ' + charData.name + '에게 경험치 보정이 주어졌습니다!', new Date()]);
      }
    }
    const result3 = await client.query('select * from global');
    for (val of result3.rows) {
      var glb = JSON.parse(val.globals);
      glb['actionUsed' + new Date()] = glb.actionUsed;
      glb.actionUsed = 0;
      glb.fieldBossSummoned = false;
      glb.fieldBossSpawned = false;
    }
    await client.query('update global set globals = $1', [JSON.stringify(glb)]);
    await client.query('delete from raids where rindex = 3');
    await client.query('delete from personal');
  }
  client.release();  
  } catch (err) {
  }
  }