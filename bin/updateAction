#!/usr/bin/env node

const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: true
}); 

const day = new Date().getDay();
const hour = new Date().getHours();
const min = new Date().getMinutes();
doWork();

async function doWork() {
try {
  const client = await pool.connect();
  // 30분마다 기본 피로도
  await client.query('update characters set actionPoint = actionPoint + 1 where actionPoint < 100');
  
    const resultx = await client.query('select * from characters');
    for (val of resultx.rows) {
      var charData = JSON.parse(val.char_data);
      charData.dungeonInfos.runMevious = false;
      charData.dungeonInfos.runEmberCrypt = false;
      charData.dungeonInfos.runFieldBoss = false;
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
    } 
  // 6시간마다 (과수원, 탄생일)
  if (hour % 6 == 0 && min < 25) {
  
    const result = await client.query('select * from characters');
    for (val of result.rows) {
      var charData = JSON.parse(val.char_data);
      charData.dungeonInfos.runBurningOrchard = false;
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
      if (charData.birth == day) {
        await client.query('update characters set actionPoint = actionPoint + 4 where uid = $1', [val.uid]);
      }
    } 
  }
  // 주말 보너스
  if ((day == 0 || day == 6) && hour % 6 == 0 && min < 25) {
    await client.query('update characters set actionPoint = actionPoint + 8');
    await client.query('update characters set actionPoint = 100 where actionPoint > 100');
  }  
  // 6시 처리 (보너스 피로도, 던전 보상, 주간 리셋, 퀘스트)
  if (hour == 6 && min < 25) {
    await client.query('update characters set actionPoint = actionPoint + 12');
    await client.query('update characters set actionPoint = 100 where actionPoint > 100');
  
    const result = await client.query('select * from characters');
    var minBattle = 999999;
    var minBattleUid;
    var minRate = 2;
    var minRateUid;
    for (val of result.rows) {
      var charData = JSON.parse(val.char_data);
      if (day == 1) {
        delete charData.dayStoneBought;
        delete charData.actionBought;
      }
      if (val.uid != '02') {
        if (charData.battleCnt < minBattle) {
          minBattle = charData.battleCnt;
          minBattleUid = val.uid;
        }
        if (charData.battleCnt && charData.winCnt / charData.battleCnt < minRate) {
          minRate = charData.winCnt / charData.battleCnt;
          minRateUid = val.uid;
        }
      }
      charData.maxExp = 5 * charData.reqExp;
      charData.resultMaxGauge = 0;
      charData.addExpCount = 3;
      charData.dungeonInfos.rewardMevious = false;
      charData.dungeonInfos.rewardEmberCrypt = false;
      charData.quest = {};
      var quests = [{code : 1, progress : 0, target : 5},
                    {code : 2, progress : 0, target : 5},
                    {code : 3, progress : 0, target : 10},
                    {code : 4, progress : 0, target : 5},
                    {code : 5, progress : 0, target : 3},
                    {code : 6, progress : 0, target : 8},
                    {code : 7, progress : 0, target : 2},
                    {code : 8, progress : 0, target : 1},
                    {code : 9, progress : 0, target : 1},
                    {code : 10, progress : 0, target : 10},
                    {code : 11, progress : 0, target : 1},
                    {code : 12, progress : 0, target : 50}];
      var rand = Math.floor(Math.random() * 12);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1);
      var rand = Math.floor(Math.random() * 11);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1);
      var rand = Math.floor(Math.random() * 10);
      var target = quests[rand];
      target.rewardType = Math.floor(Math.random() * 4);
      target.rewardAmt = 0;
      charData.quest[target.code] = target;
      quests.splice(rand, 1); 
      charData.resetQuest = true;
      
      await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
    } 
    const result2 = await client.query('select * from characters');
    for (val of result2.rows) {
      if (val.uid == minBattleUid) {
        var charData = JSON.parse(val.char_data);
        charData.expBoost = charData.expBoost ? charData.expBoost + 3 : 3;
        charData.maxExp += charData.reqExp;
        await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
        await client.query('insert into news(content, date) values ($1, $2)', 
          ['전투 횟수가 가장 적은 ' + charData.name + '에게 경험치 보정이 주어졌습니다!', new Date()]);
      }
      if (minBattleUid != minRateUid && val.uid == minRateUid) {
        var charData = JSON.parse(val.char_data);
        charData.expBoost = charData.expBoost ? charData.expBoost + 3 : 3;
        charData.maxExp += charData.reqExp;
        await client.query('update characters set char_data = $1 where uid = $2', [JSON.stringify(charData), val.uid]);
        await client.query('insert into news(content, date) values ($1, $2)', 
          ['승률이 가장 낮은 ' + charData.name + '에게 경험치 보정이 주어졌습니다!', new Date()]);
      }
    }
  }
  client.release();  
  } catch (err) {
  }
  }